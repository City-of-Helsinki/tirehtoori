import json
from io import StringIO
from pathlib import Path

import pytest
from django.core.management import call_command

from redirect.management.commands.import_redirect_rules import Command, ImporterError
from redirect.models import Domain, DomainName, RedirectRule


def _make_path(path):
    return Path(__file__).parent / path


SIMPLE_JSON_PATH = str(_make_path("test_data/import_redirect_rules/simple.json"))
MISSING_DOMAIN_NAMES_JSON_PATH = str(
    _make_path("test_data/import_redirect_rules/missing_domain_names.json")
)
ALL_ARGS_MULTIPLE_DOMAINS_JSON_PATH = str(
    _make_path("test_data/import_redirect_rules/all_args_multiple_domains.json")
)


@pytest.fixture
def import_command():
    command = Command()
    command.force = False
    return command


@pytest.fixture
def simple_json():
    with open(SIMPLE_JSON_PATH) as f:
        return json.load(f)


@pytest.fixture
def missing_domain_names_json():
    with open(MISSING_DOMAIN_NAMES_JSON_PATH) as f:
        return json.load(f)


@pytest.fixture
def all_args_multiple_domains_json():
    with open(ALL_ARGS_MULTIPLE_DOMAINS_JSON_PATH) as f:
        return json.load(f)


@pytest.mark.django_db
class IntegrationTest:
    def test_with_simple_json(self, simple_json):
        call_command("import_redirect_rules", SIMPLE_JSON_PATH)

        # Assert domain
        assert Domain.objects.count() == 1
        domain = Domain.objects.first()
        domain_from_json = simple_json[0]
        assert "Generated by import command on" in domain.notes
        assert domain_from_json["notes"] in domain.notes
        assert domain.display_name == domain_from_json["domain_names"][0]
        # Assert domain names
        assert domain.names.count() == 2
        assert set(domain.names.values_list("name", flat=True)) == set(
            domain_from_json["domain_names"]
        )
        # Assert redirect rule
        assert domain.redirect_rules.count() == 1
        rule = domain.redirect_rules.first()
        rule_from_json = domain_from_json["rules"][0]
        assert rule.path == rule_from_json["path"].strip("/")
        assert rule.destination == rule_from_json["destination"]
        assert "Generated by import command on" in rule.notes
        assert rule_from_json["notes"] in rule.notes

    def test_with_simple_json_dryrun(self, simple_json):
        out = StringIO()
        call_command("import_redirect_rules", SIMPLE_JSON_PATH, "--dry-run", stdout=out)

        assert "Running in dry-run mode" in out.getvalue()
        # Assert nothing was saved
        assert Domain.objects.count() == 0
        assert DomainName.objects.count() == 0
        assert RedirectRule.objects.count() == 0

    def test_with_missing_domain_names_json(self, missing_domain_names_json):
        with pytest.raises(ImporterError):
            call_command("import_redirect_rules", MISSING_DOMAIN_NAMES_JSON_PATH)

        # Assert nothing was saved
        assert Domain.objects.count() == 0
        assert DomainName.objects.count() == 0
        assert RedirectRule.objects.count() == 0

    def test_with_all_args_multiple_domains_json(self, all_args_multiple_domains_json):
        call_command("import_redirect_rules", ALL_ARGS_MULTIPLE_DOMAINS_JSON_PATH)

        for domain_from_json in all_args_multiple_domains_json:
            domain = Domain.objects.get(
                display_name=domain_from_json["domain_names"][0]
            )
            # Assert domain
            assert "Generated by import command on" in domain.notes
            assert domain_from_json["notes"] in domain.notes
            # Assert domain names
            assert domain.names.count() == len(domain_from_json["domain_names"])
            assert set(domain.names.values_list("name", flat=True)) == set(
                domain_from_json["domain_names"]
            )
            # Assert redirect rule
            assert domain.redirect_rules.count() == len(domain_from_json["rules"])
            for index, rule in enumerate(
                domain.redirect_rules.all().order_by("created_at")
            ):
                rule_from_json = domain_from_json["rules"][index]
                assert rule.path == rule_from_json["path"].strip("/")
                assert rule.destination == rule_from_json["destination"]
                assert rule.permanent == rule_from_json["permanent"]
                assert rule.case_sensitive == rule_from_json["case_sensitive"]
                assert rule.match_subpaths == rule_from_json["match_subpaths"]
                assert rule.append_subpath == rule_from_json["append_subpath"]
                assert rule.pass_query_string == rule_from_json["pass_query_string"]
                assert "Generated by import command on" in rule.notes
                assert rule_from_json["notes"] in rule.notes


@pytest.mark.django_db
def test_process_rule_creates_redirect_rule(import_command, domain):
    rule = {
        "path": "/test",
        "destination": "https://acme.test",
        "permanent": True,
        "case_sensitive": False,
        "pass_query_string": True,
        "match_subpaths": False,
        "append_subpath": False,
        "notes": "Test note",
    }

    import_command.process_rule(domain, rule)

    assert RedirectRule.objects.filter(domain=domain, path="test").exists()


@pytest.mark.django_db
def test_process_rule_raises_error_if_rule_exists(
    domain, import_command, redirect_rule_factory
):
    redirect_rule_factory(domain=domain, path="test", destination="https://acme.test")
    rule = {
        "path": "/test",
        "destination": "https://acme.test",
    }

    with pytest.raises(ImporterError, match=".*/test already exists.*"):
        import_command.process_rule(domain, rule)


@pytest.mark.django_db
def test_process_domain_creates_domain_and_names(import_command, monkeypatch):
    call_count = 0

    def mock_process_rule(self, domain, rule):
        nonlocal call_count
        call_count += 1

    monkeypatch.setattr(Command, "process_rule", mock_process_rule)

    item = {
        "domain_names": ["example.com"],
        "display_name": "Example",
        "notes": "Test note",
        "rules": [],
    }
    import_command.process_domain(item, 0)

    assert Domain.objects.filter(display_name="Example").exists()
    assert DomainName.objects.filter(name="example.com").exists()
    assert call_count == 0


@pytest.mark.django_db
def test_process_domain_raises_error_if_no_domain_names(import_command):
    item = {
        "domain_names": [],
        "display_name": "Example",
        "notes": "Test note",
        "rules": [],
    }

    with pytest.raises(ImporterError, match="No domain names provided.*"):
        import_command.process_domain(item, 0)


@pytest.mark.django_db
def test_process_domain_raises_error_if_domain_name_exists(import_command, domain):
    domain_name = domain.names.first().name

    item = {
        "domain_names": [domain_name],
        "display_name": "Example",
        "notes": "Test note",
        "rules": [],
    }

    with pytest.raises(
        ImporterError, match=f"Domain names .*{domain_name}.* already exist.*"
    ):
        import_command.process_domain(item, 0)


@pytest.mark.django_db
def test_process_domain_processes_rules_for_domain(import_command, monkeypatch):
    call_count = 0

    def mock_process_rule(*_, **__):
        nonlocal call_count
        call_count += 1

    monkeypatch.setattr(Command, "process_rule", mock_process_rule)

    item = {
        "domain_names": ["example.com"],
        "display_name": "Example",
        "notes": "Test note",
        "rules": [
            {
                "path": "/test",
                "destination": "https://acme.test",
            },
            {
                "path": "/test2",
                "destination": "https://acme.test2",
            },
        ],
    }
    import_command.process_domain(item, 0)

    assert Domain.objects.filter(display_name="Example").exists()
    assert call_count == 2
